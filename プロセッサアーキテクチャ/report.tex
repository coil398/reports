\documentclass{jsarticle}
\usepackage[dvipdfmx]{graphicx}
\begin{document}

\title{プロセッサアーキテクチャ特論レポート}
\author{1518511 川瀬　拓実}
\maketitle

\newpage

\section{課題1}
iPhone7

製造会社Apple

型番Apple A10

アーキテクチャARM

FLOPSは不明、おそらく300 GFLOPS程度だろうと推測されている。


HUAWEI 5.2型 P10 lite

製造会社HiSilicon

型番Kirin658

アーキテクチャARM

FLOPSは40.8 GFLOPS

\section{課題2}
動作周波数が3.0GHzで、1クロックあたり加算と乗算を8回同時に行えるので、このCPUの理論性能FLOPSは
$\rm{FLOPS} = 8 \times 2 \times 3.0\rm{G} = 48\rm{G(FLOPS)}$となる。

0.002秒あたり10000000回の加算と乗算を行なっているので、1秒あたりに換算すると
$\rm{FLOPS} = 2 \times 10000000 \div 0.002 = 10\rm{G(FLOPS)}$となる。

理論性能との比から、使用効率は
$10 \div 48 \simeq 0.208$となる。

\section{課題3}
定数の計算部分$\rm{pi * pitch / lambda}$は結果が同じになるため、ループごとに計算するのは効率の観点から望ましくない、ループの外で計算して保持する方が良い。また、徐算が行われているので予め小数に直して掛け算にすることで、処理に必要なサイクルが減り高速化が望める。
配列のラベルを、配列を使うときに計算するのではなくループの最初の部分、すなわち他の浮動小数点演算をするときに行うことで、整数演算ユニットと浮動小数点数演算ユニットが独立に計算できるので、スーパースカラ実行ができ高速化が見込める。
例として、配列を使用するときに$\rm{img\_d[i*N\_x + j]}$のようにするのではなく、コード上の不動小数点演算をする部分付近にて、新しい変数を使用して$\rm{label = i * N\_x +j}$のように配列のラベルを予め用意しておくことで効率化できる。
また、このプログラムはループが多いため、ループアンロールを行い条件分岐の回数を減らすことも効率化に寄与すると考えられる。

\newpage

\section{課題4}
パイプラインの処理時間は以下の式で表される。
\begin{eqnarray}
    (I + D - 1) \times P \nonumber
\end{eqnarray}

$I$:実行する命令数

$D$:パイプラインのステップ数

$P$:パイプラインピッチ
である。これらを①と②に適応すると、それぞれの処理時間はパイプラインフラッシュを考慮しないと

①:$(3 + 5 - 1) \times 12 = 84$
②:$(5 + 5 - 1) \times 8 = 72$

となる。単位はいずれもナノ秒である。ただし、実際の状況ではパイプラインフラッシュが起こり、その確率は段数が多いほど高まる。
1段の1ナノ秒あたりのパイプラインフラッシュの起こる確率をPとすると、1マイクロ秒あたりおよそ111回のパイプラインフラッシュが起こると両者の処理時間がおおよそ等しくなる。

\section{課題5}
アセンブラを上から読んでいくと、main関数の中で各int型の値をレジスタにコピーしていき、jmpのところでラベルL2に跳んでいる。ラベルL2の中では、まずiの中身を比較、つまり$24(\%esp)-2$が0以下になるかどうかで条件分岐を行い、0以下ならばラベルL3に跳ぶことになっている。
ここでforループの処理が行われ、iが0から2であれば、条件分岐としてラベルL2の中でcに対して値を足していく処理が行われる。
for loopの処理はラベルL2内のcmpl命令とjle命令とラベルL3内で全て行われているため、L3の前でloop処理をしたいのであれば、cmpl命令とjle命令をラベルL3の前の更にjmp命令の前に移せば良い。

\section{課題6}

\subsection{ラベルL3の中}

LDR命令によりfpの値をr2に読み込む。このとき\#-8がオフセットとして与えられる。初期値としてレジスタr2には0が入る。

MVN命令により即値15にビット毎の論理NOT演算を施したものをレジスタr3に入れる。

MOV命令によりr2レジスタに、r2レジスタの中身を即値2ビットだけ算術右シフトした値をコピーする。

SUB命令によりr0レジスタに、fpの値から4引いた値を代入する。

ADD命令によりr2レジスタに、r0レジスタの値とr2レジスタの値を足したものを代入する。

ADD命令によりr3レジスタに、r2レジスタの値とr3レジスタの値を足したものを代入する。

LDR命令によりr2レジスタに、r3のアドレスの値を代入する。

LDR命令によりr1レジスタに、fpアドレスの値を代入する。

MVN命令により即値27にビット毎の論理NOT演算を施したものをr3レジスタに代入する。

MOV命令によりr1レジスタに、r1レジスタの中身を即値2ビットだけ算術右シフトした値をコピーする。

SUB命令によりr0レジスタに、fpアドレスの値から4引いた値を代入する。

ADD命令によりr1レジスタに、r0レジスタの値とr1レジスタの値を足したものを代入する。

ADD命令によりr3レジスタに、r1レジスタの値とr3レジスタの値を足したものを代入する。

LDR命令によりr3レジスタに、r3のアドレスの値を代入する。

ADD命令によりr2レジスタに、r2レジスタの値とr3レジスタの値を足したものを代入する。

LDR命令によりr1レジスタに、fpアドレスの値を代入する。

MVN命令により即値39にビット毎の論理NOT演算を施したものをr3レジスタに代入する。

MOV命令によりr1レジスタに、r1レジスタの中身を即値2ビットだけ算術右シフトした値をコピーする。

SUB命令によりr0レジスタに、fpアドレスの値から4引いた値を代入する。

ADD命令によりr1レジスタに、r0レジスタの値とr1レジスタの値を足したものを代入する。

ADD命令によりr3レジスタに、r1レジスタの値とr3レジスタの値を足したものを代入する。

STR命令によりr2レジスタの値をr3のアドレスに書き込む。

LDR命令によりr3レジスタに、fpアドレスの値を代入する。

ADD命令によりr3レジスタに、r3レジスタの値と即値1を足したものを代入する。

STR命令によりr3レジスタの値をfpアドレスに書き込む。


\subsection{ラベルL2の中}

LDR命令によりr3レジスタに、fpアドレスの値を代入する。

CMP命令によりr3レジスタの値と即値2を比較する。

BLE命令により上記のCMPの結果が、"より小さいか等しい"であれば分岐、L3ラベルに移動する。

LDR命令によりr0レジスタに、ラベルL4から得た値を代入する。

LDR命令によりr1レジスタに、fpにオフセット-44を加えたアドレスの値を代入する。

LDR命令によりr2レジスタに、fpにオフセット-40を加えたアドレスの値を代入する。

LDR命令によりr3レジスタに、fpにオフセット-36を加えたアドレスの値を代入する。

BL命令によりサブルーチンprintfを呼び出す。

MOV命令によりr3レジスタに、即値0を代入する。

MOV命令によりr0レジスタに、r3レジスタの値を代入する。

SUB命令によりspレジスタに、fpから即値4を引いた値を代入する。

LDMFD命令によりspレジスタに、fpとpcの値を代入する。

\section{課題7}
深層学習の分野での学習のプロセスはもちろんのこと、それまで人間が行なってきた各層の構成や学習率などのいわゆるハイパーパラメータを決定する、より包括的で大規模な計算の実行。
現在スーパーコンピュータを用いて行われるシミュレーション、新しい物質（化合物や製薬など）を作るための計算や、天気予報などの地球規模や宇宙規模の計算の分野。
量子コンピュータの発明に向けて、古典的コンピュータによる量子コンピュータのシミュレーション。これらのもはや人間の手には追えない自由度の高すぎる系でのコンピュータによる計算はこれから発展が期待できる。
特に量子コンピュータについては従来のコンピュータ（古典的コンピュータ）が苦手とする並列計算が容易にできることから新たな数値計算の分野が多数生まれることは想像に難くない。

\end{document}